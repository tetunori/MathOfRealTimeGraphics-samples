"use strict";(self.webpackChunkMathOfRealTimeGraphics_samples=self.webpackChunkMathOfRealTimeGraphics_samples||[]).push([[7647],{68167:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var t=a(87462),s=(a(67294),a(3905)),h=a(72915);const r={sidebar_position:5},o="2_3_hash2d3d",i={unversionedId:"chapter2/2_3_hash2d3d",id:"chapter2/2_3_hash2d3d",title:"2_3_hash2d3d",description:"\u30b3\u30fc\u30c9 2.4, \u56f3 2.7:",source:"@site/i18n/jp/docusaurus-plugin-content-docs/current/chapter2/2_3_hash2d3d.md",sourceDirName:"chapter2",slug:"/chapter2/2_3_hash2d3d",permalink:"/MathOfRealTimeGraphics-samples/docs/chapter2/2_3_hash2d3d",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"2_2_hash1d",permalink:"/MathOfRealTimeGraphics-samples/docs/chapter2/2_2_hash1d"},next:{title:"Chapter 3: Value Noise",permalink:"/MathOfRealTimeGraphics-samples/docs/category/chapter-3-value-noise"}},c={},u=[{value:"\u30b3\u30fc\u30c9 2.4, \u56f3 2.7:",id:"\u30b3\u30fc\u30c9-24-\u56f3-27",level:2}],l={toc:u};function p(n){let{components:e,...a}=n;return(0,s.kt)("wrapper",(0,t.Z)({},l,a,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"2_3_hash2d3d"},"2_3_hash2d3d"),(0,s.kt)("h2",{id:"\u30b3\u30fc\u30c9-24-\u56f3-27"},"\u30b3\u30fc\u30c9 2.4, \u56f3 2.7:"),(0,s.kt)(h.Z,{fragName:"2_3_hash2d3d.frag",fragCode:"#version 300 es\nprecision highp float;\nprecision highp int;\nout vec4 fragColor;\nuniform float u_time;\nuniform vec2 u_resolution;\nivec2 channel;\n\nconst uint UINT_MAX = 0xffffffffu;\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\n\nuvec2 uhash22(uvec2 n){\n  n ^= (n.yx << u.xy);\n  n ^= (n.yx >> u.xy);\n  n *= k.xy;\n  n ^= (n.yx << u.xy);\n  return n * k.xy;\n}\n\nuvec3 uhash33(uvec3 n){\n  n ^= (n.yzx << u);\n  n ^= (n.yzx >> u);\n  n *= k;\n  n ^= (n.yzx << u);\n  return n * k;\n}\n\nvec2 hash22(vec2 p){\n  uvec2 n = floatBitsToUint(p);\n  return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\n\nvec3 hash33(vec3 p){\n  uvec3 n = floatBitsToUint(p);\n  return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n\nfloat hash21(vec2 p){\n  uvec2 n = floatBitsToUint(p);\n  return float(uhash22(n).x) / float(UINT_MAX);\n  //nesting approach\n  //return float(uhash11(n.x+uhash11(n.y)) / float(UINT_MAX)\n}\n\nfloat hash31(vec3 p){\n  uvec3 n = floatBitsToUint(p);\n  return float(uhash33(n).x) / float(UINT_MAX);\n  //nesting approach\n  //return float(uhash11(n.x+uhash11(n.y+uhash11(n.z))) / float(UINT_MAX)\n}\n\nvoid main()\n{\n  float time = floor(60.* u_time);\n  vec2 pos = gl_FragCoord.xy + time;\n  channel = ivec2(gl_FragCoord.xy * 2.0 / u_resolution.xy);\n  \n  if (channel[0] == 0){ //left\n    if (channel[1] == 0){\n      fragColor.rgb = vec3(hash21(pos));\n    } else {\n      fragColor.rgb = vec3(hash22(pos), 1.0);\n    }\n  } else {  //right\n    if (channel[1] == 0){\n      fragColor.rgb = vec3(hash31(vec3(pos, time)));\n    } else {\n      fragColor.rgb = hash33(vec3(pos, time));\n    }\n  }\n  fragColor.a = 1.0;\n}",mdxType:"LiveGlslCodeBlock"}))}p.isMDXComponent=!0}}]);
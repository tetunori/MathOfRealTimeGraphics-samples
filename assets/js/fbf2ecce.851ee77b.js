"use strict";(self.webpackChunkMathOfRealTimeGraphics_samples=self.webpackChunkMathOfRealTimeGraphics_samples||[]).push([[2746],{41282:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>h,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var t=a(87462),s=(a(67294),a(3905)),o=a(72915);const r={sidebar_position:5},h="2_3_hash2d3d",i={unversionedId:"chapter2/2_3_hash2d3d",id:"chapter2/2_3_hash2d3d",title:"2_3_hash2d3d",description:"Code 2.4, Figure 2.7:",source:"@site/docs/chapter2/2_3_hash2d3d.md",sourceDirName:"chapter2",slug:"/chapter2/2_3_hash2d3d",permalink:"/MathOfRealTimeGraphics-samples/docs/chapter2/2_3_hash2d3d",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"2_2_hash1d",permalink:"/MathOfRealTimeGraphics-samples/docs/chapter2/2_2_hash1d"},next:{title:"Chapter 3: Value Noise",permalink:"/MathOfRealTimeGraphics-samples/docs/category/chapter-3-value-noise"}},c={},u=[{value:"Code 2.4, Figure 2.7:",id:"code-24-figure-27",level:2}],l={toc:u};function p(n){let{components:e,...a}=n;return(0,s.kt)("wrapper",(0,t.Z)({},l,a,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"2_3_hash2d3d"},"2_3_hash2d3d"),(0,s.kt)("h2",{id:"code-24-figure-27"},"Code 2.4, Figure 2.7:"),(0,s.kt)(o.Z,{fragName:"2_3_hash2d3d.frag",fragCode:"#version 300 es\nprecision highp float;\nprecision highp int;\nout vec4 fragColor;\nuniform float u_time;\nuniform vec2 u_resolution;\nivec2 channel;\n\nconst uint UINT_MAX = 0xffffffffu;\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n    //nesting approach\n    //return float(uhash11(n.x+uhash11(n.y)) / float(UINT_MAX)\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n    //nesting approach\n    //return float(uhash11(n.x+uhash11(n.y+uhash11(n.z))) / float(UINT_MAX)\n}\n\nvoid main()\n{\n    float time = floor(60.* u_time);\n    vec2 pos = gl_FragCoord.xy + time;\n    channel = ivec2(gl_FragCoord.xy * 2.0 / u_resolution.xy);\n    if (channel[0] == 0){ //left\n        if (channel[1] == 0){\n            fragColor.rgb = vec3(hash21(pos));\n        } else {\n            fragColor.rgb = vec3(hash22(pos), 1.0);\n        }\n    } else {    //right\n        if (channel[1] == 0){\n            fragColor.rgb = vec3(hash31(vec3(pos, time)));\n        } else {\n            fragColor.rgb = hash33(vec3(pos, time));\n        }\n    }\n    fragColor.a = 1.0;\n}",mdxType:"LiveGlslCodeBlock"}))}p.isMDXComponent=!0}}]);